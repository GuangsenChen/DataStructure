### 递归需要满足的三个条件：
- 一个问题的解可以分解为几个子问题的解
  - “自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样的子问题。
- 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
  - 求解“自己在哪一排”和前面的人求解“自己在哪一排”的思路是一模一样的。
- 存在递归终止条件
  - 第一排的人不需要再集训询问任何人，就知道自己在第一排，这就是递归的终止条件。

> 举个例子：周末你带着女朋友去电影院去看电影，女朋友问你，咱们现在坐在第几排？电影院里面太黑了，看不清，没法数，现在你怎么办？
>
> 别忘了你是程序员，这时递归就派上用场了。于是你问前面一排的人他是第几排，你想只要在他的排数上加一，就知道自己在哪一排了。但是前面的人也不知道他是第几排，所以他也问前面的人。就这样一排一排往前问，知道问到第一排的人，说我在第一排，然后一排一排再把数字传回来。知道前面的人告诉你他在哪一排，于是你就知道答案了。



### 写递归代码要注意两点：

- 递归代码要警惕堆栈溢出
  - 如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。
- 递归代码要警惕重复计算
  - 如果递归过程中已经计算过f(k)，当递归调用到f(k)时，先看下是否已经求解过了，如果是，则直接从保存f(k)的数据结构中取f(k)的值返回。
- 防止出现无限递归的问题
- 编写递归代码的关键是不要把自己绕进去，正确姿势是写出递推公式，找出终止条件，然后再翻译成递归代码。
  - 如果一个问题A可以分解为若干子问题B、C、D，你可以假设子问题B、C、D已经解决，在此基础上思考如何解决问题A。而且，只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层一层往下思考子问题与子子问题的关系。



